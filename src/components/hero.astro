---
import Profile from '../components/profilepic.astro';
import Brief from '../components/brief.astro';
import Skills from '../components/skill.astro';
import Contact from '../components/contact.astro';

const base = import.meta.env.PUBLIC_BASE_URL;
---

<div
  id="hero-section"
  class="relative flex flex-row gap-4 justify-center items-center w-full h-screen"
>
  <div
    id="scroll-indicator-top"
    class="absolute top-4 left-1/2 -translate-x-1/2 z-20 transition-opacity duration-300 opacity-0 pointer-events-none text-primary"
  >
    <div class="animate-bounce p-2">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="4"
        stroke="currentColor"
        class="w-6 h-6"
      >
        <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5"></path>
      </svg>
    </div>
  </div>

  <div id="hero-carousel" class="px-4 carousel carousel-vertical h-screen overflow-y-auto">
    <div class="carousel-item min-h-screen" data-hero-panel="intro">
      <Brief />
    </div>
    <div class="carousel-item min-h-screen" data-hero-panel="skills">
      <Skills />
    </div>
    <div class="carousel-item min-h-screen" data-hero-panel="contact">
      <div class="flex flex-col justify-center h-screen">
        <Contact />
      </div>
    </div>
  </div>

  <div
    id="scroll-indicator-bottom"
    class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 transition-opacity duration-300 pointer-events-none text-primary"
  >
    <div class="animate-bounce p-2">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="4"
        stroke="currentColor"
        class="w-6 h-6"
      >
        <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path>
      </svg>
    </div>
  </div>

  <div class="hidden md:block" style="view-transition-name:profile;">
    <div class="tooltip tooltip-primary">
      <div class="tooltip-content">
        <div class="animate-bounce text-primary-content -rotate-3 text-2xl font-black">
          Click for more!!!
        </div>
      </div>
      <a href={base + 'about/'}>
        <Profile />
      </a>
    </div>
  </div>
</div>

<script>
  (() => {
    if (typeof window === 'undefined') {
      return;
    }

    const heroSection = document.getElementById('hero-section');
    const carousel = document.getElementById('hero-carousel');
    const topIndicator = document.getElementById('scroll-indicator-top');
    const bottomIndicator = document.getElementById('scroll-indicator-bottom');
    const heroPanels = carousel ? Array.from(carousel.querySelectorAll('[data-hero-panel]')) : [];

    if (!heroSection || !carousel || heroPanels.length === 0) {
      return;
    }

    const cleanupTasks = [];
    const flushCleanups = () => {
      while (cleanupTasks.length) {
        const dispose = cleanupTasks.pop();
        if (typeof dispose === 'function') {
          dispose();
        }
      }
    };

    document.addEventListener('astro:before-swap', flushCleanups, { once: true });

    const panelIndexMap = new Map();
    heroPanels.forEach((panel, index) => {
      panelIndexMap.set(panel, index);
      if (!panel.dataset.heroIndex) {
        panel.dataset.heroIndex = String(index);
      }
    });

    const setIndicatorVisibility = (index) => {
      if (topIndicator) {
        topIndicator.classList.toggle('opacity-0', index <= 0);
      }
      if (bottomIndicator) {
        bottomIndicator.classList.toggle('opacity-0', index >= heroPanels.length - 1);
      }
    };

    const setActivePanelAttributes = (index) => {
      const panel = heroPanels[index];
      if (!panel) return;

      const panelId = panel.dataset.heroPanel || String(index);

      heroSection.dataset.heroActivePanel = panelId;
      heroSection.dataset.heroActiveIndex = String(index);
      carousel.dataset.activePanel = panelId;
      carousel.dataset.activeIndex = String(index);

      heroPanels.forEach((candidate, candidateIndex) => {
        if (candidateIndex === index) {
          candidate.setAttribute('data-hero-current', 'true');
        } else {
          candidate.removeAttribute('data-hero-current');
        }
      });

      setIndicatorVisibility(index);
    };

    const prefersMotionQuery =
      typeof window.matchMedia === 'function'
        ? window.matchMedia('(prefers-reduced-motion: reduce)')
        : null;

    let observerThreshold = 0.6;
    const syncMotionPreference = () => {
      const prefersReducedMotion = prefersMotionQuery ? prefersMotionQuery.matches : false;
      heroSection.dataset.prefersReducedMotion = prefersReducedMotion ? 'true' : 'false';
      observerThreshold = prefersReducedMotion ? 0.5 : 0.6;
    };

    syncMotionPreference();

    if (prefersMotionQuery) {
      const handleMotionChange = () => syncMotionPreference();

      if (typeof prefersMotionQuery.addEventListener === 'function') {
        prefersMotionQuery.addEventListener('change', handleMotionChange);
        cleanupTasks.push(() => prefersMotionQuery.removeEventListener('change', handleMotionChange));
      } else if (typeof prefersMotionQuery.addListener === 'function') {
        prefersMotionQuery.addListener(handleMotionChange);
        cleanupTasks.push(() => prefersMotionQuery.removeListener(handleMotionChange));
      }
    }

    if (!('IntersectionObserver' in window)) {
      setActivePanelAttributes(0);
      return;
    }

    const buildThresholdSteps = (steps = 12) =>
      Array.from({ length: steps + 1 }, (_, index) => index / steps);

    let activeIndex = 0;
    setActivePanelAttributes(activeIndex);

    const observer = new IntersectionObserver(
      (entries) => {
        let nextIndex = activeIndex;
        let highestRatio = 0;

        entries.forEach((entry) => {
          const panelIndex = panelIndexMap.get(entry.target);
          if (typeof panelIndex !== 'number') return;

          if (entry.isIntersecting && entry.intersectionRatio >= observerThreshold) {
            if (entry.intersectionRatio > highestRatio) {
              highestRatio = entry.intersectionRatio;
              nextIndex = panelIndex;
            }
          }
        });

        if (nextIndex !== activeIndex) {
          activeIndex = nextIndex;
          setActivePanelAttributes(activeIndex);
        }
      },
      {
        root: carousel,
        threshold: buildThresholdSteps(),
      }
    );

    heroPanels.forEach((panel) => observer.observe(panel));
    cleanupTasks.push(() => observer.disconnect());
  })();
</script>
